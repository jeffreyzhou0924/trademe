ğŸ”§ æå–çº¯Pythonä»£ç æˆåŠŸï¼
åŸå§‹é•¿åº¦: 8082 å­—ç¬¦
æå–åé•¿åº¦: 7591 å­—ç¬¦
âœ… Pythonè¯­æ³•éªŒè¯é€šè¿‡

ğŸ“‹ æå–çš„çº¯Pythonä»£ç ï¼š
from app.core.enhanced_strategy import EnhancedBaseStrategy, DataRequest, DataType
from app.core.strategy_engine import TradingSignal, SignalType
from typing import List, Optional, Dict, Any
from datetime import datetime
import pandas as pd
import numpy as np

class UserStrategy(EnhancedBaseStrategy):
    """ä¼˜åŒ–çš„MAå‡çº¿äº¤å‰ç­–ç•¥ - åŸºäºSMA5å’ŒSMA10é‡‘å‰æ­»å‰"""
    
    def __init__(self):
        super().__init__()
        self.symbol = "BTC-USDT-SWAP"
        self.timeframe = "1h"
        
        # ç­–ç•¥å‚æ•°
        self.sma_short_period = 5
        self.sma_long_period = 10
        self.position_size = 0.10  # æ¯æ¬¡å¼€ä»“10%èµ„é‡‘
        self.stop_loss_pct = 5.0   # æ­¢æŸ5%
        self.take_profit_pct = 5.0 # æ­¢ç›ˆ5%
        
        # ä¼˜åŒ–å‚æ•°
        self.kdj_k_period = 9
        self.kdj_d_period = 3
        self.kdj_smooth = 3
        
        # çŠ¶æ€è·Ÿè¸ª
        self.last_signal = None
        self.signal_confirmed = False
        self.position_direction = None
        
    def get_data_requirements(self) -> List[DataRequest]:
        """å®šä¹‰ç­–ç•¥æ‰€éœ€çš„æ•°æ®æº"""
        return [
            DataRequest(
                data_type=DataType.KLINE,
                exchange="okx",
                symbol=self.symbol,
                timeframe=self.timeframe,
                required=True
            )
        ]
    
    def calculate_kdj(self, high: pd.Series, low: pd.Series, close: pd.Series, 
                      k_period: int = 9, d_period: int = 3, smooth: int = 3) -> tuple:
        """è®¡ç®—KDJæŒ‡æ ‡"""
        lowest_low = low.rolling(window=k_period).min()
        highest_high = high.rolling(window=k_period).max()
        
        rsv = ((close - lowest_low) / (highest_high - lowest_low)) * 100
        rsv = rsv.fillna(50)
        
        k = rsv.ewm(span=smooth).mean()
        d = k.ewm(span=d_period).mean()
        j = 3 * k - 2 * d
        
        return k, d, j
    
    def detect_golden_cross(self, sma_short: pd.Series, sma_long: pd.Series) -> bool:
        """æ£€æµ‹é‡‘å‰ä¿¡å·"""
        if len(sma_short) < 2 or len(sma_long) < 2:
            return False
        
        # å½“å‰çŸ­å‡çº¿åœ¨é•¿å‡çº¿ä¸Šæ–¹ï¼Œä¸”å‰ä¸€æ ¹Kçº¿çŸ­å‡çº¿åœ¨é•¿å‡çº¿ä¸‹æ–¹
        current_cross = sma_short.iloc[-1] > sma_long.iloc[-1]
        previous_cross = sma_short.iloc[-2] <= sma_long.iloc[-2]
        
        return current_cross and previous_cross
    
    def detect_death_cross(self, sma_short: pd.Series, sma_long: pd.Series) -> bool:
        """æ£€æµ‹æ­»å‰ä¿¡å·"""
        if len(sma_short) < 2 or len(sma_long) < 2:
            return False
        
        # å½“å‰çŸ­å‡çº¿åœ¨é•¿å‡çº¿ä¸‹æ–¹ï¼Œä¸”å‰ä¸€æ ¹Kçº¿çŸ­å‡çº¿åœ¨é•¿å‡çº¿ä¸Šæ–¹
        current_cross = sma_short.iloc[-1] < sma_long.iloc[-1]
        previous_cross = sma_short.iloc[-2] >= sma_long.iloc[-2]
        
        return current_cross and previous_cross
    
    def should_add_position(self, signal_type: SignalType) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥åŠ ä»“"""
        # é‡å¤ä¿¡å·åŠ ä»“é€»è¾‘
        if self.position_direction is None:
            return True
        
        # åŒæ–¹å‘ä¿¡å·å…è®¸åŠ ä»“
        if signal_type == SignalType.BUY and self.position_direction == "long":
            return True
        elif signal_type == SignalType.SELL and self.position_direction == "short":
            return True
        
        return False
    
    def get_kdj_filter(self, k: pd.Series, d: pd.Series, j: pd.Series, signal_type: SignalType) -> bool:
        """KDJè¿‡æ»¤æ¡ä»¶ - ä¼˜åŒ–ç‰ˆæœ¬"""
        if len(k) < 1 or len(d) < 1:
            return True  # æ•°æ®ä¸è¶³æ—¶ä¸è¿‡æ»¤
        
        current_k = k.iloc[-1]
        current_d = d.iloc[-1]
        
        # ä¹°å…¥ä¿¡å·ï¼šKDJä¸åœ¨è¶…ä¹°åŒºåŸŸ
        if signal_type == SignalType.BUY:
            return current_k < 80 and current_d < 80
        
        # å–å‡ºä¿¡å·ï¼šKDJä¸åœ¨è¶…å–åŒºåŸŸ  
        elif signal_type == SignalType.SELL:
            return current_k > 20 and current_d > 20
        
        return True
    
    async def on_data_update(self, data_type: str, data: Dict[str, Any]) -> Optional[TradingSignal]:
        """æ•°æ®æ›´æ–°å¤„ç† - å®ç°MAå‡çº¿äº¤å‰ç­–ç•¥"""
        if data_type != "kline":
            return None
        
        # è·å–Kçº¿æ•°æ®
        df = self.get_kline_data()
        if df is None or len(df) < max(self.sma_long_period, self.kdj_k_period) + 2:
            return None
        
        # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        sma_short = self.calculate_sma(df['close'], self.sma_short_period)
        sma_long = self.calculate_sma(df['close'], self.sma_long_period)
        
        # è®¡ç®—KDJæŒ‡æ ‡ç”¨äºè¿‡æ»¤
        k, d, j = self.calculate_kdj(df['high'], df['low'], df['close'], 
                                     self.kdj_k_period, self.kdj_d_period, self.kdj_smooth)
        
        if sma_short is None or sma_long is None:
            return None
        
        current_price = df['close'].iloc[-1]
        
        # æ£€æµ‹é‡‘å‰å’Œæ­»å‰
        golden_cross = self.detect_golden_cross(sma_short, sma_long)
        death_cross = self.detect_death_cross(sma_short, sma_long)
        
        signal = None
        
        # é‡‘å‰å¼€å¤šé€»è¾‘
        if golden_cross:
            # KDJè¿‡æ»¤æ¡ä»¶
            if self.get_kdj_filter(k, d, j, SignalType.BUY):
                # å…ˆå¹³ä»“å†å¼€åå‘ä»“
                if self.position_direction == "short":
                    # å‘é€å¹³ä»“ä¿¡å·
                    self.position_direction = None
                
                # åˆ¤æ–­æ˜¯å¦åŠ ä»“æˆ–å¼€æ–°ä»“
                if self.should_add_position(SignalType.BUY):
                    signal = TradingSignal(
                        signal_type=SignalType.BUY,
                        symbol=self.symbol,
                        price=current_price,
                        quantity=self.position_size,
                        stop_loss=current_price * (1 - self.stop_loss_pct / 100),
                        take_profit=current_price * (1 + self.take_profit_pct / 100),
                        metadata={
                            "strategy": "ma_cross_optimized",
                            "signal_reason": "golden_cross",
                            "sma_short": float(sma_short.iloc[-1]),
                            "sma_long": float(sma_long.iloc[-1]),
                            "kdj_k": float(k.iloc[-1]),
                            "kdj_d": float(d.iloc[-1]),
                            "position_size_pct": self.position_size * 100
                        }
                    )
                    self.position_direction = "long"
        
        # æ­»å‰å¼€ç©ºé€»è¾‘
        elif death_cross:
            # KDJè¿‡æ»¤æ¡ä»¶
            if self.get_kdj_filter(k, d, j, SignalType.SELL):
                # å…ˆå¹³ä»“å†å¼€åå‘ä»“
                if self.position_direction == "long":
                    # å‘é€å¹³ä»“ä¿¡å·
                    self.position_direction = None
                
                # åˆ¤æ–­æ˜¯å¦åŠ ä»“æˆ–å¼€æ–°ä»“
                if self.should_add_position(SignalType.SELL):
                    signal = TradingSignal(
                        signal_type=SignalType.SELL,
                        symbol=self.symbol,
                        price=current_price,
                        quantity=self.position_size,
                        stop_loss=current_price * (1 + self.stop_loss_pct / 100),
                        take_profit=current_price * (1 - self.take_profit_pct / 100),
                        metadata={
                            "strategy": "ma_cross_optimized",
                            "signal_reason": "death_cross",
                            "sma_short": float(sma_short.iloc[-1]),
                            "sma_long": float(sma_long.iloc[-1]),
                            "kdj_k": float(k.iloc[-1]),
                            "kdj_d": float(d.iloc[-1]),
                            "position_size_pct": self.position_size * 100
                        }
                    )
                    self.position_direction = "short"
        
        return signal
